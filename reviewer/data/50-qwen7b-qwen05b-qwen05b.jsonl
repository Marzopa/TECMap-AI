{"id":"50ce5fdf-2cbb-403d-91c2-46f155aefabf","topic":"arrays","difficulty":1,"additionalTopics":[],"excludedTopics":[],"content":"Given an array of integers, write a function to return the maximum number in the array without using any built-in max() or similar functions. Ensure your solution handles both positive and negative integers.","tags":["recursion","loops","conditionals","hashmap","arrays","string manipulation","sorting"],"latencyMs":46705,"generatedAt":"2025-06-10T16:09:19.370351300Z"}
{"id":"58fc8a85-5f71-45b4-bbc9-a59eb6e7fc60","topic":"arrays","difficulty":1,"additionalTopics":[],"excludedTopics":[],"content":"Write a function that reverses an array in place without using any additional data structures.","tags":["recursion"],"latencyMs":9209,"generatedAt":"2025-06-10T16:09:28.580329600Z"}
{"id":"d7519bb7-47ad-423c-9963-02e1a7c1430e","topic":"arrays","difficulty":1,"additionalTopics":[],"excludedTopics":[],"content":"Given an array of integers, write a function to determine if the array is sorted in non-decreasing order.","tags":["recursion","loops","conditionals","hashmap","arrays","string manipulation","sorting"],"latencyMs":11151,"generatedAt":"2025-06-10T16:09:39.732260400Z"}
{"id":"2e528fa8-93e1-49fc-adf4-c17a9b4ca9b9","topic":"arrays","difficulty":1,"additionalTopics":[],"excludedTopics":[],"content":"Write a function that checks if an array is sorted in non-decreasing order. The function should return `true` if the array is sorted, otherwise it should return `false`.","tags":["recursion","loops","conditionals","hashmap","arrays","string manipulation","sorting"],"latencyMs":12870,"generatedAt":"2025-06-10T16:09:52.602568200Z"}
{"id":"9d594771-5939-48c8-9d89-3434b116ef3c","topic":"arrays","difficulty":1,"additionalTopics":[],"excludedTopics":[],"content":"Write a function that takes an array of integers and returns the maximum value found in the array. Ensure your function handles arrays with all negative numbers correctly.","tags":["recursion","loops","conditionals","hashmap","arrays","string manipulation","sorting"],"latencyMs":12501,"generatedAt":"2025-06-10T16:10:05.104518200Z"}
{"id":"aa6c7558-4026-42ea-b32d-1fcafd9bd483","topic":"strings","difficulty":1,"additionalTopics":[],"excludedTopics":["regex"],"content":"Write a function that determines whether a given string is a palindrome (i.e., reads the same forwards and backwards). The function should ignore case sensitivity and spaces.","tags":["recursion","loops","conditionals","hashmap","arrays","string manipulation","sorting"],"latencyMs":14918,"generatedAt":"2025-06-10T16:10:20.023836900Z"}
{"id":"67a0398a-606e-488e-a2cb-7e8037048bc2","topic":"strings","difficulty":1,"additionalTopics":[],"excludedTopics":["regex"],"content":"Write a function that takes a string as input and returns true if the string is a palindrome (reads the same backward as forward), and false otherwise.","tags":["recursion","loops","conditionals","hashmap","arrays","string manipulation","sorting"],"latencyMs":12860,"generatedAt":"2025-06-10T16:10:32.884429600Z"}
{"id":"9c4839dd-6295-4b8c-80ec-6ad803b0d841","topic":"strings","difficulty":1,"additionalTopics":[],"excludedTopics":["regex"],"content":"Write a function that determines whether a given string is a palindrome. A palindrome reads the same backward as forward, ignoring cases and spaces. For example, \\A man a plan a canal Panama\\ is a palindrome.","tags":["recursion","loops","conditionals","hashmap","arrays","string manipulation","sorting"],"latencyMs":13956,"generatedAt":"2025-06-10T16:10:46.842069200Z"}
{"id":"13de1958-68a7-44a0-95af-c302e386e156","topic":"strings","difficulty":1,"additionalTopics":[],"excludedTopics":["regex"],"content":"Given two strings, write a function to determine if they are anagrams of each other. An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. For example, \\listen\\ and \\silent\\ are anagrams.","tags":["anagram","recursion"],"latencyMs":16005,"generatedAt":"2025-06-10T16:11:02.847121300Z"}
{"id":"bf2b9333-41e6-4d19-b191-9b16e32a93bf","topic":"strings","difficulty":1,"additionalTopics":[],"excludedTopics":["regex"],"content":"Given two strings, write a function to determine if they are anagrams of each other. An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.","tags":["anagram","sorting"],"latencyMs":13857,"generatedAt":"2025-06-10T16:11:16.704620100Z"}
{"id":"497dd7fd-cff1-48e9-a01e-9866ab8e644e","topic":"linked lists","difficulty":2,"additionalTopics":["iteration"],"excludedTopics":["recursion"],"content":"Implement a function to reverse a singly linked list iteratively. The function should return the new head of the reversed list. Ensure your solution handles an empty list and a list with a single node correctly.","tags":["recursion","loops","conditionals","hashmap","arrays","string manipulation","sorting","iteration"],"latencyMs":15114,"generatedAt":"2025-06-10T16:11:31.820032300Z"}
{"id":"c5d3f319-6e8e-4b0c-8181-6a003e118468","topic":"linked lists","difficulty":2,"additionalTopics":["iteration"],"excludedTopics":["recursion"],"content":"Given a singly-linked list, write a function to reverse the list iteratively without using any extra space. Return the new head of the reversed list.","tags":["recursion"],"latencyMs":11307,"generatedAt":"2025-06-10T16:11:43.127380200Z"}
{"id":"56aed18e-6c05-4bdb-8d10-b9dd9ebdc11f","topic":"linked lists","difficulty":2,"additionalTopics":["iteration"],"excludedTopics":["recursion"],"content":"Implement a function that takes two linked lists of integers and returns a new linked list representing their sum. Each node in the input linked lists contains a single digit, and the digits are stored in reverse order (i.e., the least significant digit is at the head of each list). Assume both lists are non-empty and do not contain any leading zeros except for the number zero itself.","tags":["recursion","loops","conditionals","hashmap","arrays","string manipulation","sorting","linked list","recursion","loops","conditionals","hashmap","arrays","string manipulation","sorting","linked list","recursion","loops","conditionals","hashmap","arrays","string manipulation","sorting","linked list","recursion","loops","conditionals"],"latencyMs":19428,"generatedAt":"2025-06-10T16:12:02.556149700Z"}
{"id":"ee4b302f-cf2a-4f57-8ea9-74a56936b4e7","topic":"linked lists","difficulty":2,"additionalTopics":["iteration"],"excludedTopics":["recursion"],"content":"Given a singly linked list, write a function to remove all nodes that have duplicate values, leaving only nodes with unique values in the list. Ensure your function returns the head of the modified list. Assume the linked list contains integers and is not empty.","tags":["recursion","loops","conditionals","hashmap","arrays","string manipulation","sorting"],"latencyMs":14627,"generatedAt":"2025-06-10T16:12:17.184066400Z"}
{"id":"b4ac962f-44b1-41f3-98a1-d629124f6dd6","topic":"linked lists","difficulty":2,"additionalTopics":["iteration"],"excludedTopics":["recursion"],"content":"Implement a function to reverse a singly-linked list without using any additional data structures. The function should take the head of the list as input and return the new head of the reversed list. Ensure that your solution handles edge cases, such as an empty list or a list with only one node.","tags":["recursion","loops","conditionals","hashmap","arrays","string manipulation","sorting"],"latencyMs":15726,"generatedAt":"2025-06-10T16:12:32.910429500Z"}
{"id":"a606e0f0-7545-4af0-8382-340af2b904e3","topic":"hash maps","difficulty":2,"additionalTopics":[],"excludedTopics":["dynamic programming"],"content":"Design a function that takes a list of strings and returns a dictionary where the keys are the unique words in the list and the values are the number of occurrences of each word. Ensure the function handles case sensitivity (i.e., \\Hello\\ and \\hello\\ should be considered different).","tags":["recursion","loops","conditionals","hashmap","arrays","string manipulation","sorting"],"latencyMs":17828,"generatedAt":"2025-06-10T16:12:50.740016400Z"}
{"id":"c2c39e24-3636-49e2-8c2c-dfebb2cf434a","topic":"hash maps","difficulty":2,"additionalTopics":[],"excludedTopics":["dynamic programming"],"content":"Given a list of words, create a hash map where the keys are the unique words and the values are their frequencies in the list. Ensure your function handles both uppercase and lowercase letters by normalizing them to lowercase.","tags":["hashmap","recursion"],"latencyMs":13530,"generatedAt":"2025-06-10T16:13:04.270489500Z"}
{"id":"bc4cd6b5-ea7d-4c8f-8aa8-03416d5d1786","topic":"hash maps","difficulty":2,"additionalTopics":[],"excludedTopics":["dynamic programming"],"content":"Given a list of strings, write a function to return the string with the maximum frequency. If multiple strings have the same maximum frequency, return the one that appears first in the list. Ensure your solution handles an empty list gracefully by returning `None`.","tags":["recursion","loops","conditionals","hashmap","arrays","string manipulation","sorting"],"latencyMs":15053,"generatedAt":"2025-06-10T16:13:19.324536600Z"}
{"id":"7292c9bf-90ab-423d-9946-129bd09289ea","topic":"hash maps","difficulty":2,"additionalTopics":[],"excludedTopics":["dynamic programming"],"content":"Write a function that takes two strings as input and returns true if they are anagrams of each other (i.e., contain the same characters in any order).","tags":["recursion","loops","conditionals","hashmap","arrays","string manipulation","sorting"],"latencyMs":12160,"generatedAt":"2025-06-10T16:13:31.484498300Z"}
{"id":"872ff2a8-038d-47c3-be25-9b4a00a46d7d","topic":"hash maps","difficulty":2,"additionalTopics":[],"excludedTopics":["dynamic programming"],"content":"Write a function that takes an array of strings as input and returns the count of unique strings in the array. Ensure your solution handles cases with duplicate strings efficiently.","tags":["recursion","loops","conditionals","hashmap","arrays","string manipulation","sorting"],"latencyMs":12330,"generatedAt":"2025-06-10T16:13:43.814832500Z"}
{"id":"50a49406-7a6d-4d40-97cd-b1550c21d108","topic":"stacks & queues","difficulty":2,"additionalTopics":[],"excludedTopics":["graphs"],"content":"Given a sequence of strings where each string is either an opening bracket '(', a closing bracket ')', or a digit, write a function that returns the maximum depth of nested parentheses for any subsequence formed by consecutive digits enclosed in brackets. For example, given the input \\a(123)b(45)()\\ the function should return 3 because the deepest level of nesting is achieved by the subsequence \\123)\\","tags":["recursion","loops","conditionals","hashmap","arrays","string manipulation","sorting","recursion"],"latencyMs":22759,"generatedAt":"2025-06-10T16:14:06.575708Z"}
{"id":"73b62c31-2e46-4521-a043-ea820bd80dab","topic":"stacks & queues","difficulty":2,"additionalTopics":[],"excludedTopics":["graphs"],"content":"Implement a stack using only two queues. Ensure your implementation supports push, pop, peek, and is empty operations.","tags":["recursion","loops","conditionals","hashmap","arrays","string manipulation","sorting"],"latencyMs":13407,"generatedAt":"2025-06-10T16:14:19.983797300Z"}
{"id":"28fd444b-aeeb-4284-9bd7-eaec1dff5820","topic":"stacks & queues","difficulty":2,"additionalTopics":[],"excludedTopics":["graphs"],"content":"Implement a function to evaluate postfix expressions using a stack. The function should handle basic arithmetic operations (+, -, *, /) and integers.","tags":["recursion","loops","conditionals","hashmap","arrays","string manipulation","sorting"],"latencyMs":13817,"generatedAt":"2025-06-10T16:14:33.801444200Z"}
{"id":"7763476c-4642-42ca-8e27-27995029a83c","topic":"stacks & queues","difficulty":2,"additionalTopics":[],"excludedTopics":["graphs"],"content":"Implement a stack using only two queues. Your implementation should support the standard operations `push`, `pop`, `top`, and `empty`.","tags":["recursion","loops","conditionals","hashmap","arrays","string manipulation","sorting"],"latencyMs":13579,"generatedAt":"2025-06-10T16:14:47.381360700Z"}
{"id":"47c6db71-3647-4fc5-aa21-6cab0cc1c88a","topic":"stacks & queues","difficulty":2,"additionalTopics":[],"excludedTopics":["graphs"],"content":"Implement a stack using only two queues. Ensure your stack supports the operations push, pop, peek, and is empty.","tags":["recursion","loops","conditionals","hashmap","arrays","string manipulation","sorting"],"latencyMs":11184,"generatedAt":"2025-06-10T16:14:58.566155100Z"}
{"id":"490f657c-6658-4449-a857-4bea17b0bae0","topic":"binary search","difficulty":3,"additionalTopics":["recursion"],"excludedTopics":["graphs"],"content":"Write a recursive function to perform binary search on a sorted array and return the index of the target value if it exists. If the target is not found, return -1.","tags":["recursion","sorting"],"latencyMs":15506,"generatedAt":"2025-06-10T16:15:14.072487600Z"}
{"id":"f4a15f36-ccf6-4681-92a9-455dd13522cc","topic":"binary search","difficulty":3,"additionalTopics":["recursion"],"excludedTopics":["graphs"],"content":"Implement a recursive function to perform binary search on a sorted array of integers. The function should return the index of the target value if it is found, or -1 if the target is not present in the array. Ensure that the function handles edge cases such as empty arrays and repeated elements efficiently.","tags":["recursion","arrays","string manipulation","sorting"],"latencyMs":17335,"generatedAt":"2025-06-10T16:15:31.408413900Z"}
{"id":"a38e510f-97ff-40eb-8160-0d65cf48b444","topic":"binary search","difficulty":3,"additionalTopics":["recursion"],"excludedTopics":["graphs"],"content":"Write a recursive function that performs binary search on a sorted array to find the index of a given target value. If the target is not found, return -1. Ensure your solution handles arrays with duplicate values correctly by returning the index of the first occurrence of the target.","tags":["recursion","sorting"],"latencyMs":15983,"generatedAt":"2025-06-10T16:15:47.391904300Z"}
{"id":"58e61ffa-3e2b-4e4e-ab6a-774a577949ac","topic":"binary search","difficulty":3,"additionalTopics":["recursion"],"excludedTopics":["graphs"],"content":"Implement a recursive version of the binary search algorithm to find a target value within a sorted array. The function should return the index of the target if it exists in the array, or -1 if it does not. Ensure that your implementation handles arrays with duplicate elements correctly.","tags":["recursion","loops","conditionals","hashmap","arrays","string manipulation","sorting"],"latencyMs":16403,"generatedAt":"2025-06-10T16:16:03.795870800Z"}
{"id":"f7025533-b905-4681-b11e-ebd814bc7bd0","topic":"binary search","difficulty":3,"additionalTopics":["recursion"],"excludedTopics":["graphs"],"content":"Implement a recursive function to perform binary search on a sorted array. The function should take an array of integers, the target integer to find, and the indices for the start and end of the current search range. Return the index of the target if found; otherwise, return -1. Ensure your implementation handles edge cases such as empty arrays and targets outside the range of the array values.","tags":["recursion","loops","conditionals","hashmap","arrays","string manipulation","sorting"],"latencyMs":20069,"generatedAt":"2025-06-10T16:16:23.866214200Z"}
{"id":"35b246db-98d4-4b29-a68f-08764616fe99","topic":"sorting algorithms","difficulty":3,"additionalTopics":["selection sort"],"excludedTopics":["quick sort"],"content":"Implement a selection sort algorithm to sort an array of integers in ascending order. Ensure your implementation handles arrays with duplicate values and is case-sensitive when comparing strings.","tags":["recursion","loops","conditionals","hashmap","arrays","string manipulation","sorting","case-sensitive"],"latencyMs":16753,"generatedAt":"2025-06-10T16:16:40.619367600Z"}
{"id":"017f5ac0-c438-4833-9750-d3f3b515c8d9","topic":"sorting algorithms","difficulty":3,"additionalTopics":["selection sort"],"excludedTopics":["quick sort"],"content":"Implement the Selection Sort algorithm to sort an array of integers in ascending order. Ensure your implementation is clear and follows best practices for readability.","tags":["selection","sorting"],"latencyMs":12350,"generatedAt":"2025-06-10T16:16:52.970433400Z"}
{"id":"3ce8a052-4ea1-49bf-a280-27e2e69e41f4","topic":"sorting algorithms","difficulty":3,"additionalTopics":["selection sort"],"excludedTopics":["quick sort"],"content":"Implement a selection sort algorithm to sort an array of integers in ascending order. Ensure your implementation includes comments explaining each step of the process and handles edge cases such as empty arrays or arrays with duplicate values correctly.","tags":["selection","sorting"],"latencyMs":14376,"generatedAt":"2025-06-10T16:17:07.347539100Z"}
{"id":"7f5ee5a5-450e-4711-b800-b722f48cb62b","topic":"sorting algorithms","difficulty":3,"additionalTopics":["selection sort"],"excludedTopics":["quick sort"],"content":"Implement a selection sort algorithm to sort an array of integers in ascending order. Ensure your implementation includes comments explaining each step of the algorithm and handles duplicates correctly.","tags":["selection","sorting"],"latencyMs":12715,"generatedAt":"2025-06-10T16:17:20.062916800Z"}
{"id":"f9124256-0e45-4e2c-bbef-c4f7261f57d8","topic":"sorting algorithms","difficulty":3,"additionalTopics":["selection sort"],"excludedTopics":["quick sort"],"content":"Implement a selection sort algorithm to sort an array of integers. Ensure your implementation sorts the array in ascending order.","tags":["recursion","loops","conditionals","hashmap","arrays","string manipulation","sorting"],"latencyMs":11485,"generatedAt":"2025-06-10T16:17:31.548256200Z"}
{"id":"3a8e68ad-2bf6-4029-950d-820792718a2f","topic":"graphs","difficulty":4,"additionalTopics":["BFS"],"excludedTopics":["DFS","dynamic programming"],"content":"Given a graph represented as an adjacency list and two nodes `start` and `end`, write a function to determine the shortest path from `start` to `end` using Breadth-First Search (BFS). The function should return the length of the shortest path. If there is no path from `start` to `end`, return -1. Assume that each node in the graph has a unique identifier and that the input graph is connected.","tags":["recursion","loops","conditionals","hashmap","arrays","string manipulation","sorting","graphs"],"latencyMs":26090,"generatedAt":"2025-06-10T16:17:57.639376200Z"}
{"id":"6984726f-30f8-4374-9c37-efe0c4a0b868","topic":"graphs","difficulty":4,"additionalTopics":["BFS"],"excludedTopics":["DFS","dynamic programming"],"content":"Given a graph represented as an adjacency list, implement a breadth-first search (BFS) algorithm to find the shortest path from a source vertex to a destination vertex. The function should return the shortest path if it exists, or indicate that no path is found.","tags":["recursion","loops","conditionals","hashmap","arrays","string manipulation","sorting"],"latencyMs":16443,"generatedAt":"2025-06-10T16:18:14.082480700Z"}
{"id":"00dbeb46-4973-4236-bb98-d75db1410cad","topic":"graphs","difficulty":4,"additionalTopics":["BFS"],"excludedTopics":["DFS","dynamic programming"],"content":"Given a graph represented as an adjacency list, implement the Breadth-First Search (BFS) algorithm to find the shortest path from a source node to a target node. Return the length of the shortest path if it exists; otherwise, return -1. Assume all edge weights are 1.","tags":["recursion","loops","conditionals","hashmap","arrays","string manipulation","sorting","graphs"],"latencyMs":18456,"generatedAt":"2025-06-10T16:18:32.539695100Z"}
{"id":"104b81f8-f3ee-4573-824f-3704c3b301d6","topic":"graphs","difficulty":4,"additionalTopics":["BFS"],"excludedTopics":["DFS","dynamic programming"],"content":"Given a graph represented as an adjacency list, implement a Breadth-First Search (BFS) algorithm to determine the shortest path from a source vertex to all other vertices in the graph. Ensure your implementation handles both directed and undirected graphs and correctly identifies if there is no path between the source and certain vertices.","tags":["recursion","graph traversal","BFS"],"latencyMs":18375,"generatedAt":"2025-06-10T16:18:50.914835200Z"}
{"id":"12cf4676-faf0-4f90-8bd5-32bb7adbfe8f","topic":"graphs","difficulty":4,"additionalTopics":["BFS"],"excludedTopics":["DFS","dynamic programming"],"content":"Given a graph represented as an adjacency list and two vertices `s` and `t`, implement a function to find the shortest path from vertex `s` to vertex `t` using Breadth-First Search (BFS). The function should return the length of the shortest path. If no path exists, return -1.","tags":["recursion","loops","conditionals","hashmap","arrays","string manipulation","sorting","graphs"],"latencyMs":18596,"generatedAt":"2025-06-10T16:19:09.512527100Z"}
{"id":"d5ab3442-f532-45c9-b60a-135c633473c1","topic":"dynamic programming","difficulty":4,"additionalTopics":["memoization"],"excludedTopics":["graphs"],"content":"Implement a function `fibonacci(n)` using dynamic programming and memoization to calculate the nth Fibonacci number. The function should efficiently handle large values of n without redundant calculations.","tags":["recursion","loops","conditionals","hashmap","arrays","string manipulation","sorting"],"latencyMs":15626,"generatedAt":"2025-06-10T16:19:25.138853400Z"}
{"id":"b7ceafd7-ba2d-48a3-abf7-8905b9c27f18","topic":"dynamic programming","difficulty":4,"additionalTopics":["memoization"],"excludedTopics":["graphs"],"content":"Given a sequence of non-negative integers, find the maximum sum such that no two elements in the sum are adjacent.","tags":["recursion","loops","conditionals","hashmap","arrays","string manipulation","sorting"],"latencyMs":11531,"generatedAt":"2025-06-10T16:19:36.670650100Z"}
{"id":"1d9c2ca8-4e5d-4e60-91d6-fb05ea04294b","topic":"dynamic programming","difficulty":4,"additionalTopics":["memoization"],"excludedTopics":["graphs"],"content":"Given a sequence of integers, find the maximum sum of a contiguous subsequence. You may not select two adjacent elements in the subsequence. Use memoization to optimize your solution.","tags":["recursion","memoization"],"latencyMs":13690,"generatedAt":"2025-06-10T16:19:50.360419700Z"}
{"id":"50e1a795-53f2-48a4-878a-ef8585973bbb","topic":"dynamic programming","difficulty":4,"additionalTopics":["memoization"],"excludedTopics":["graphs"],"content":"Develop a function to calculate the maximum profit from a single buy and sell operation on an array of stock prices, where you must buy before you can sell. Use memoization to optimize your solution for better performance.","tags":["recursion","loops","conditionals","hashmap","arrays","string manipulation","sorting","memoization"],"latencyMs":14630,"generatedAt":"2025-06-10T16:20:04.991232700Z"}
{"id":"91d38321-a8fd-4bcc-9742-a99d278cf5cd","topic":"dynamic programming","difficulty":4,"additionalTopics":["memoization"],"excludedTopics":["graphs"],"content":"Given a list of non-negative integers, write a function that finds the length of the longest contiguous subarray where the sum of elements is a perfect square.","tags":["recursion","loops","conditionals","hashmap","arrays","string manipulation","sorting","recursion"],"latencyMs":13741,"generatedAt":"2025-06-10T16:20:18.732916200Z"}
{"id":"36fd75cb-010d-4136-ac0b-f6dcf34991df","topic":"arrays","difficulty":5,"additionalTopics":["two-pointer"],"excludedTopics":["graphs","binary trees"],"content":"Given an unsorted array of integers `nums`, return the maximum sum of a non-empty subarray that is not larger than a given integer `k`. Solve this problem using the sliding window technique with two pointers. Ensure your solution efficiently handles cases where elements are negative and optimizes for time complexity.","tags":["recursion","loops","conditionals","hashmap","arrays","string manipulation","sorting"],"latencyMs":19981,"generatedAt":"2025-06-10T16:20:38.715484Z"}
{"id":"35f64459-c386-4926-8f16-4feaa0edfc16","topic":"arrays","difficulty":5,"additionalTopics":["two-pointer"],"excludedTopics":["graphs","binary trees"],"content":"Given an unsorted array of integers, find the minimum number of adjacent swaps required to sort the array in ascending order using the two-pointer technique. The function should return -1 if sorting is not possible with swaps (i.e., if there are any inversions that cannot be resolved with adjacent swaps).","tags":["recursion","loops","conditionals","hashmap","arrays","string manipulation","sorting"],"latencyMs":17499,"generatedAt":"2025-06-10T16:20:56.214687400Z"}
{"id":"69b915f8-583c-4286-82ef-5123f3b26ac1","topic":"arrays","difficulty":5,"additionalTopics":["two-pointer"],"excludedTopics":["graphs","binary trees"],"content":"Given an unsorted array of integers, write a function that finds three numbers such that their sum is zero. Your solution should avoid using any nested loops beyond what is necessary and should handle edge cases efficiently. Return all unique triplets in the array which gives the sum of zero. Note: Elements in each triplet must be in non-descending order.","tags":["recursion","sorting"],"latencyMs":18955,"generatedAt":"2025-06-10T16:21:15.171014800Z"}
{"id":"f88ba97c-6ead-4336-bcd9-f3281e9b34e3","topic":"arrays","difficulty":5,"additionalTopics":["two-pointer"],"excludedTopics":["graphs","binary trees"],"content":"Given a sorted array `nums`, find the first occurrence of a target value in `nums`. If the target is not found, return `-1`. You must implement this with an efficient algorithm that runs in O(log n) time complexity.\\n\\n**Additional Topics:** Two-pointer technique\\n\\n**Excluded Topics:** Graphs, Binary trees","tags":["recursion","loops","conditionals","hashmap","arrays","string manipulation","sorting","graphs","binary trees"],"latencyMs":18589,"generatedAt":"2025-06-10T16:21:33.759944900Z"}
{"id":"de9d4b4b-1647-451b-bade-939a410a100e","topic":"arrays","difficulty":5,"additionalTopics":["two-pointer"],"excludedTopics":["graphs","binary trees"],"content":"Given a sorted array of distinct integers, write a function to find the pair of elements that sums up to a given target. If no such pair exists, return null. Use the two-pointer technique for your solution.","tags":["recursion","sorting"],"latencyMs":14414,"generatedAt":"2025-06-10T16:21:48.174817100Z"}
